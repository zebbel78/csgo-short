<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <title>CS:GO Poseidon Tournament - Official</title>
    <style>
        :root { --cs-orange: #ff9d00; --cs-blue: #0c192c; --cs-dark: #1b1e21; --text: #e0e0e0; }
        body { font-family: 'Arial', sans-serif; background: var(--cs-blue); color: var(--text); padding: 20px; }
        .container { max-width: 900px; margin: auto; background: var(--cs-dark); padding: 25px; border-radius: 12px; border-top: 6px solid var(--cs-orange); box-shadow: 0 10px 40px rgba(0,0,0,0.6); }
        h1, h2 { text-align: center; color: var(--cs-orange); letter-spacing: 2px; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th { background: #25282c; padding: 12px; border-bottom: 2px solid var(--cs-orange); }
        td { padding: 10px; border-bottom: 1px solid #333; }
        input { background: #2c3136; border: 1px solid #444; color: white; padding: 8px; border-radius: 4px; width: 80%; }
        .btn { width: 100%; padding: 15px; background: var(--cs-orange); border: none; font-weight: bold; cursor: pointer; border-radius: 6px; font-size: 1.1em; }
        .btn:hover { background: #fff; }
        .btn-add { background: #4caf50; color: white; margin-bottom: 10px; width: auto; padding: 10px 20px; }
        
        .bracket-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 40px; margin-top: 30px; }
        .match-box { background: #25282c; padding: 15px; margin-bottom: 20px; border-left: 4px solid var(--cs-orange); position: relative; }
        .match-label { font-size: 0.7em; color: var(--cs-orange); font-weight: bold; text-transform: uppercase; }
        .final-box { grid-column: 1 / span 2; border: 2px solid var(--cs-orange); background: #2a2510; text-align: center; }
        .final-box .team-name { font-size: 2.2em; font-weight: 800; }
        .final-box .vs { font-size: 4em; }
        .rank-tag { font-size: 0.8em; opacity: 0.7; font-style: italic; }
        .hidden { display: none; }
        @font-face {
            font-family: 'Martyric';
            src: url('fonts/Martyric.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        .team-names { text-align:center; margin-bottom:6px; }
        .team-name { font-size:1.25em; font-weight:700; display:inline-block; margin:0 6px; }
        .vs { text-align:center; font-size:2.2em; color: var(--cs-orange); font-weight:900; margin:8px 0; font-family: 'Martyric', 'Streefight', Impact, 'Arial Black', sans-serif; }
        .scores-row { text-align:center; margin-top:8px; }
        .winner-text { color: var(--cs-orange); text-shadow: 0 0 8px var(--cs-orange); }
        .loser-text { opacity: 0.45; color: #999; }
        .flash { animation: flash-text 0.9s ease-in-out infinite alternate; }
        @keyframes flash-text {
            from { text-shadow: none; transform: none; }
            to { text-shadow: 0 0 14px var(--cs-orange); transform: scale(1.02); }
        }
    </style>
</head>
<body>

<div class="container">
    <h1>ðŸ”±POSEIDON TOERNOOI</h1>

    <div id="setup">
        <h2>Fase 1: Deathmatch Qualifiers</h2>
        <p style="text-align:center;">Voer kills in. De top 8 gaat door naar de Wingman Knockout.</p>
        <table>
            <thead>
                <tr><th>Naam Speler</th><th>Map 1 Kills</th><th>Map 2 Kills</th></tr>
            </thead>
            <tbody id="player-rows">
                </tbody>
        </table>
        <button class="btn btn-add" onclick="addRow()">+ Speler Toevoegen</button>
        <button class="btn btn-add" style="background:#2196F3; margin-left:8px;" onclick="fillDummyData()">Vul Dummy Data</button>
        <button class="btn" onclick="startKnockout()">GENEREER KNOCKOUT BRACKET</button>
    </div>

    <div id="bracket-view" class="hidden">
        <h2>Fase 2: Wingman Knockout</h2>
        <p style="text-align:center; color: #aaa;">Map: <strong>de_poseidon</strong></p>
        
        <div class="bracket-grid">
            <div id="semi-1">
                <div class="match-label">Halve Finale 1</div>
                <div class="match-box" id="m1-content"></div>
            </div>
            <div id="semi-2">
                <div class="match-label">Halve Finale 2</div>
                <div class="match-box" id="m2-content"></div>
            </div>
            <div class="final-box">
                <div class="match-label" style="color: var(--cs-orange);">Grote Finale</div>
                <!-- final determined automatically from semi winners -->
                <div class="match-box" style="border:none; background:transparent;">
                    <div id="final-winners"><strong>Winnaar HF1 vs Winnaar HF2</strong></div>
                </div>
            </div>
        </div>
        <!-- team scoreboard removed -->

        <div style="margin-top:14px;">
            <h3 style="text-align:center; color:var(--cs-orange);">Deathmatch Scoreboard</h3>
            <table id="player-scoreboard" style="width:70%; margin:auto;">
                <thead>
                    <tr><th>Naam</th><th>Map 1</th><th>Map 2</th><th>Totaal</th></tr>
                </thead>
                <tbody id="player-scoreboard-body"></tbody>
            </table>
        </div>

        <button class="btn" style="margin-top:40px; background:#444; color:white;" onclick="location.reload()">RESET TOERNOOI</button>
    </div>
</div>

<script>
    // Start met 10 velden (zodat je wat te filteren hebt)
    for(let i=0; i<10; i++) addRow();
    // attach listeners to inputs so changes auto-save
    attachInputListeners();

    function addRow() {
        const row = document.createElement('tr');
        row.innerHTML = `<td><input type="text" class="p-name" placeholder="Naam..."></td>
                         <td><input type="number" class="p-m1" value="0"></td>
                         <td><input type="number" class="p-m2" value="0"></td>`;
        document.getElementById('player-rows').appendChild(row);
        attachInputListeners();
    }

    function applyBracketCodes() {
        // removed: final is determined automatically from semifinal results
    }

    // manual confirm removed â€” semifinals are auto-evaluated via score inputs (first-to-9 rule)

    function updateFinalIfReady() {
        const s = window.semiResults || {};
        if(s[1] && s[2]) {
            // Render enhanced final block (names big, VS styled, inputs below)
            const leftTeam = s[1];
            const rightTeam = s[2];
            document.getElementById('final-winners').innerHTML = `
                <div class="team-names">
                    <span id="final-left" class="team-name final-team" data-code="${leftTeam.code}">${leftTeam.p1.name} &nbsp;&amp;&nbsp; ${leftTeam.p2.name}</span>
                </div>
                <div class="vs">VS</div>
                <div class="team-names">
                    <span id="final-right" class="team-name final-team" data-code="${rightTeam.code}">${rightTeam.p1.name} &nbsp;&amp;&nbsp; ${rightTeam.p2.name}</span>
                </div>
                <div class="scores-row">
                    <input id="final-score-${leftTeam.code}" type="number" value="0" style="width:80px; margin-right:10px;"> <input id="final-score-${rightTeam.code}" type="number" value="0" style="width:80px; margin-left:10px;">
                </div>
                <div id="final-winner-note" style="text-align:center; margin-top:8px; color:#ddd;"></div>
            `;

            // wire up auto-eval for final (first-to-9)
            setupFinalAutoConfirm(leftTeam.code, rightTeam.code);

            // evaluate immediately in case inputs were prefilled
            try { evaluateFinal(leftTeam.code, rightTeam.code); } catch(e){}

            // clear previous visual winner state
            window.finalWinner = null;
            removeFinalFlash();

            autoSave();
        }
    }
    // scoreboard omitted in server mode

    function getPlayersFromInputs() {
        const players = [];
        const names = document.querySelectorAll('.p-name');
        const m1s = document.querySelectorAll('.p-m1');
        const m2s = document.querySelectorAll('.p-m2');
        names.forEach((n, i) => {
            const name = n.value.trim();
            const m1 = parseInt((m1s[i] && m1s[i].value) || 0, 10) || 0;
            const m2 = parseInt((m2s[i] && m2s[i].value) || 0, 10) || 0;
            if(name !== '') players.push({ name, m1, m2, total: m1 + m2 });
        });
        return players;
    }

    function autoSave() {
        // gather current state and POST to server /save
        const players = getPlayersFromInputs();
        const teams = window.currentTeams || [];
        const semiResults = window.semiResults || {};
        const data = { players, teams, semiResults, finalWinner: window.finalWinner || null, timestamp: new Date().toISOString() };
        try {
            fetch('/save', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            }).catch(err => {
                console.error('autosave POST failed', err);
                try { localStorage.setItem('toernooi_data', JSON.stringify(data)); } catch(e) {}
            });
        } catch(e) {
            try { localStorage.setItem('toernooi_data', JSON.stringify(data)); } catch(e) {}
        }
        // refresh deathmatch scoreboard immediately
        try { populatePlayerScoreboard(getPlayersFromInputs()); } catch(e) {}
    }

    function attachInputListeners() {
        const names = document.querySelectorAll('.p-name');
        const m1s = document.querySelectorAll('.p-m1');
        const m2s = document.querySelectorAll('.p-m2');
        const handler = () => { autoSave(); try { populatePlayerScoreboard(getPlayersFromInputs()); } catch(e){} };
        names.forEach(n => { n.removeEventListener('input', handler); n.addEventListener('input', handler); });
        m1s.forEach(i => { i.removeEventListener('input', handler); i.addEventListener('input', handler); });
        m2s.forEach(i => { i.removeEventListener('input', handler); i.addEventListener('input', handler); });
    }

    function setupAutoConfirmForSemi(codeA, codeB, semiIndex) {
        const aEl = document.getElementById('score-' + codeA);
        const bEl = document.getElementById('score-' + codeB);
        if(!aEl || !bEl) return;
        const tryAuto = () => evaluateSemi(codeA, codeB, semiIndex);
        aEl.addEventListener('input', tryAuto);
        bEl.addEventListener('input', tryAuto);
    }

    function setupFinalAutoConfirm(codeA, codeB) {
        const aEl = document.getElementById('final-score-' + codeA);
        const bEl = document.getElementById('final-score-' + codeB);
        if(!aEl || !bEl) return;
        const tryAuto = () => evaluateFinal(codeA, codeB);
        aEl.addEventListener('input', tryAuto);
        bEl.addEventListener('input', tryAuto);
    }

    function evaluateFinal(codeA, codeB) {
        const aEl = document.getElementById('final-score-' + codeA);
        const bEl = document.getElementById('final-score-' + codeB);
        if(!aEl || !bEl) return;
        const aVal = parseInt(aEl.value || 0, 10) || 0;
        const bVal = parseInt(bEl.value || 0, 10) || 0;
        const teams = window.currentTeams || [];
        const teamA = teams.find(t => t.code === codeA);
        const teamB = teams.find(t => t.code === codeB);
        if(!teamA || !teamB) return;
        // first-to-9 auto-win (also handle prefilled or postfilled higher score)
        if((aVal >= 9 || bVal >= 9)) {
            if(aVal > bVal) { declareFinalWinner(codeA); return; }
            if(bVal > aVal) { declareFinalWinner(codeB); return; }
        }
        // if neither reaches 9, clear final winner note
        if(!window.finalWinner) {
            const note = document.getElementById('final-winner-note');
            if(note) note.innerText = '';
        }
    }

    function declareFinalWinner(code) {
        const teams = window.currentTeams || [];
        const winner = teams.find(t => t.code === code);
        if(!winner) return;
        window.finalWinner = winner;
        // flash winner element
        removeFinalFlash();
        const leftEl = document.getElementById('final-left');
        const rightEl = document.getElementById('final-right');
        if(leftEl && rightEl) {
            const leftCode = leftEl.dataset && leftEl.dataset.code;
            const rightCode = rightEl.dataset && rightEl.dataset.code;
            if(leftCode === winner.code) {
                leftEl.classList.add('flash','winner-text');
                rightEl.classList.add('loser-text');
            } else if(rightCode === winner.code) {
                rightEl.classList.add('flash','winner-text');
                leftEl.classList.add('loser-text');
            }
        }
        // show note
        const note = document.getElementById('final-winner-note');
        if(note) note.innerText = 'Winnaar: ' + winner.p1.name + ' & ' + winner.p2.name;
        // confetti (persistent while winner remains)
        try { runConfetti(true); } catch(e){}
        autoSave();
    }

    function removeFinalFlash() {
        const leftEl = document.getElementById('final-left');
        const rightEl = document.getElementById('final-right');
        if(leftEl) { leftEl.classList.remove('flash'); leftEl.classList.remove('winner-text','loser-text'); }
        if(rightEl) { rightEl.classList.remove('flash'); rightEl.classList.remove('winner-text','loser-text'); }
    }

    // --- Confetti (simple) ---
    function runConfetti() {
        // runConfetti(persistent=false) - if persistent true, keep confetti until cleared
        const persistent = arguments.length ? !!arguments[0] : false;
        // avoid stacking multiple persistent canvases
        if(persistent && window._confettiRunning) return;

        const canvas = persistent && window._confettiCanvas ? window._confettiCanvas : document.createElement('canvas');
        if(persistent) {
            window._confettiCanvas = canvas;
            window._confettiRunning = true;
        }
        canvas.style.position = 'fixed';
        canvas.style.left = 0;
        canvas.style.top = 0;
        canvas.style.pointerEvents = 'none';
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if(!canvas.parentNode) document.body.appendChild(canvas);
        const ctx = canvas.getContext('2d');

        // prefer theme orange and gold tones
        const root = getComputedStyle(document.documentElement);
        const orange = (root.getPropertyValue('--cs-orange') || '#ff9d00').trim();
        const colors = [orange, '#ffd700', '#ffdd57', '#ffb84d'];

        const particles = [];
        for(let i=0;i<180;i++) particles.push({ x: Math.random()*canvas.width, y: Math.random()*-canvas.height, r: (Math.random()*6)+4, d: Math.random()*50, color: colors[Math.floor(Math.random()*colors.length)], tilt: Math.random()*10-10 });

        function draw() {
            ctx.clearRect(0,0,canvas.width, canvas.height);
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.ellipse(p.x, p.y, p.r, p.r*0.6, p.tilt*Math.PI/180, 0, Math.PI*2);
                ctx.fill();
            });
        }
        function update() {
            const now = Date.now();
            particles.forEach(p => {
                p.y += Math.random()*6 + 2;
                p.x += Math.sin(now/100 + p.d) * 2;
                p.tilt += 0.5;
                if(p.y > canvas.height + 20) { p.y = -10; p.x = Math.random()*canvas.width; }
            });
        }

        function loop() {
            draw(); update();
            if(persistent) {
                // keep running until finalWinner is cleared
                if(window.finalWinner) requestAnimationFrame(loop);
                else {
                    // stop and cleanup
                    window._confettiRunning = false;
                    if(canvas && canvas.parentNode) canvas.parentNode.removeChild(canvas);
                    window._confettiCanvas = null;
                }
            } else {
                // short burst
                const duration = 3000;
                const end = Date.now() + duration;
                (function burst() { draw(); update(); if(Date.now() < end) requestAnimationFrame(burst); else { if(canvas && canvas.parentNode) canvas.parentNode.removeChild(canvas); } })();
            }
        }
        loop();
    }

    function evaluateSemi(codeA, codeB, semiIndex) {
        const aVal = parseInt((document.getElementById('score-' + codeA) && document.getElementById('score-' + codeA).value) || 0, 10) || 0;
        const bVal = parseInt((document.getElementById('score-' + codeB) && document.getElementById('score-' + codeB).value) || 0, 10) || 0;
        const teams = window.currentTeams || [];
        const teamA = teams.find(t => t.code === codeA);
        const teamB = teams.find(t => t.code === codeB);
        if(!teamA || !teamB) return;
        const prev = (window.semiResults || {})[semiIndex] || null;
        let winner = null;
        if(aVal >= 9 && aVal > bVal) winner = teamA;
        else if(bVal >= 9 && bVal > aVal) winner = teamB;
        // if winner changed, update display and final
        const prevCode = prev ? prev.code : null;
        const newCode = winner ? winner.code : null;
        if(prevCode !== newCode) {
            window.semiResults = window.semiResults || {};
            window.semiResults[semiIndex] = winner;
            const el = document.getElementById('winner-semi' + semiIndex);
            if(el) el.innerText = winner ? ('Winnaar: ' + winner.p1.name + ' & ' + winner.p2.name + ' [' + winner.code + ']') : 'Nog geen winnaar';
            // highlight winner text and dim loser
            const leftId = `semi${semiIndex}-left`;
            const rightId = `semi${semiIndex}-right`;
            const leftEl = document.getElementById(leftId);
            const rightEl = document.getElementById(rightId);
            if(leftEl && rightEl) {
                if(winner === teamA) {
                    leftEl.classList.add('winner-text'); leftEl.classList.remove('loser-text');
                    rightEl.classList.add('loser-text'); rightEl.classList.remove('winner-text');
                } else if(winner === teamB) {
                    rightEl.classList.add('winner-text'); rightEl.classList.remove('loser-text');
                    leftEl.classList.add('loser-text'); leftEl.classList.remove('winner-text');
                } else {
                    // no winner: clear styles
                    leftEl.classList.remove('winner-text','loser-text');
                    rightEl.classList.remove('winner-text','loser-text');
                }
            }
            updateFinalIfReady();
            autoSave();
            // team scoreboard removed
        }
    }

    function populatePlayerScoreboard(players) {
        const tbody = document.getElementById('player-scoreboard-body');
        if(!tbody) return;
        tbody.innerHTML = '';
        const sorted = (players || []).slice().sort((a,b) => b.total - a.total);
        sorted.forEach(p => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${p.name}</td><td>${p.m1}</td><td>${p.m2}</td><td>${p.total}</td>`;
            tbody.appendChild(tr);
        });
    }
    

    function fillDummyData() {
        const sample = [
            {name: 'Alpha', m1: 12, m2: 9},
            {name: 'Bravo', m1: 11, m2: 10},
            {name: 'Charlie', m1: 9, m2: 8},
            {name: 'Delta', m1: 8, m2: 7},
            {name: 'Echo', m1: 7, m2: 6},
            {name: 'Foxtrot', m1: 6, m2: 5},
            {name: 'Golf', m1: 5, m2: 4},
            {name: 'Hotel', m1: 4, m2: 3},
            {name: 'India', m1: 3, m2: 2},
            {name: 'Juliet', m1: 2, m2: 1},
            {name: 'Kilo', m1: 1, m2: 0},
            {name: 'Lima', m1: 0, m2: 0}
        ];

        const tbody = document.getElementById('player-rows');
        tbody.innerHTML = '';
        sample.forEach(s => {
            const row = document.createElement('tr');
            row.innerHTML = `<td><input type="text" class="p-name" value="${s.name}"></td>` +
                            `<td><input type="number" class="p-m1" value="${s.m1}"></td>` +
                            `<td><input type="number" class="p-m2" value="${s.m2}"></td>`;
            tbody.appendChild(row);
        });
        // automatically generate the bracket so you can continue without extra clicks
        startKnockout();
    }

    // team scoreboard removed

    function startKnockout() {
        // read players from inputs (includes m1,m2,total)
        let players = getPlayersFromInputs();

        if(players.length < 8) return alert("Je hebt minimaal 8 spelers nodig voor de top 8!");

        // 1. Sorteer op kills
        players.sort((a, b) => b.total - a.total);

        // expose all players for scoreboard / JSON
        window.currentPlayers = players;

        // 2. Pak de top 8
        const top8 = players.slice(0, 8);

        // 3. Maak teams volgens #1+#8, #2+#7, #3+#6, #4+#5
        const teams = [
            { id: "Team 1", p1: top8[0], p2: top8[7], rank: "1 & 8" },
            { id: "Team 2", p1: top8[1], p2: top8[6], rank: "2 & 7" },
            { id: "Team 3", p1: top8[2], p2: top8[5], rank: "3 & 6" },
            { id: "Team 4", p1: top8[3], p2: top8[4], rank: "4 & 5" }
        ];

        // Assign short codes for each team so users can enter winners by code
        teams.forEach((t, i) => { t.code = 'C' + (i+1); });

        // expose teams for code mapping (used by applyBracketCodes)
        window.currentTeams = teams;

        // 4. Vul de bracket (Semi 1: T1 vs T4 | Semi 2: T2 vs T3)
        // Dit zorgt dat de sterkste teams (1 en 2) elkaar pas in de finale zien.
        document.getElementById('m1-content').innerHTML = `
            <div class="team-names">
                <span id="semi1-left" class="team-name">${teams[0].p1.name} &nbsp;&amp;&nbsp; ${teams[0].p2.name}</span>
            </div>
            <div class="vs">VS</div>
            <div class="team-names">
                <span id="semi1-right" class="team-name">${teams[3].p1.name} &nbsp;&amp;&nbsp; ${teams[3].p2.name}</span>
            </div>
            <div class="scores-row">
                <input id="score-${teams[0].code}" type="number" value="0" style="width:80px; margin-right:10px;"> <input id="score-${teams[3].code}" type="number" value="0" style="width:80px; margin-left:10px;">
                <div id="winner-semi1" style="margin-top:8px; font-style:italic; color:#ccc;"></div>
            </div>
        `;

        document.getElementById('m2-content').innerHTML = `
            <div class="team-names">
                <span id="semi2-left" class="team-name">${teams[1].p1.name} &nbsp;&amp;&nbsp; ${teams[1].p2.name}</span>
            </div>
            <div class="vs">VS</div>
            <div class="team-names">
                <span id="semi2-right" class="team-name">${teams[2].p1.name} &nbsp;&amp;&nbsp; ${teams[2].p2.name}</span>
            </div>
            <div class="scores-row">
                <input id="score-${teams[1].code}" type="number" value="0" style="width:80px; margin-right:10px;"> <input id="score-${teams[2].code}" type="number" value="0" style="width:80px; margin-left:10px;">
                <div id="winner-semi2" style="margin-top:8px; font-style:italic; color:#ccc;"></div>
            </div>
        `;

        // initialize semi results storage
        window.semiResults = { 1: null, 2: null };

        // saved current state will be written by autoSave()

        // set up auto-confirm listeners for semi score inputs
        setupAutoConfirmForSemi(teams[0].code, teams[3].code, 1);
        setupAutoConfirmForSemi(teams[1].code, teams[2].code, 2);

        // saved current state
        autoSave();

        // populate deathmatch (player) scoreboard
        populatePlayerScoreboard(window.currentPlayers || []);

        document.getElementById('setup').classList.add('hidden');
        document.getElementById('bracket-view').classList.remove('hidden');
    }
</script>

</body>
</html>